import fs from "node:fs";
import { electronApp, optimizer } from "@electron-toolkit/utils";
import { BrowserWindow, app, dialog, ipcMain, Menu, shell } from "electron";
import type { IVideoMetadata } from "src/types";
import {
  generateThumbnailSprite,
  getMetadata,
  processVideoFrame,
} from "./utils/videoUtils";
import type { IProjectData } from "./components/types";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const VIDEO_FRAME_EXTRACTOR_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

let mainWindow: BrowserWindow | null = null;
let frameExtractorWindow: BrowserWindow | null = null;
let currentTheme = "dark";
let currentProjectTitle = "";
let currentFilePath = "";
let isProjectOpen = false;
let canCopy = false;
let canPaste = false;

const createMainWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    autoHideMenuBar: false,
    height: 768,
    show: false,
    width: 1024,
    icon: "resources/icon.png",
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: true,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  mainWindow.on("ready-to-show", () => {
    mainWindow?.webContents.send("theme-update", currentTheme);
    mainWindow?.show();
  });

  // Open the DevTools.
  if (process.env.NODE_ENV === "development") {
    mainWindow.webContents.openDevTools();
  }

  mainWindow.on("closed", () => {
    mainWindow = null;
  });
};

const createFrameExtractorWindow = (metadata: IVideoMetadata): void => {
  if (mainWindow) {
    frameExtractorWindow = new BrowserWindow({
      width: 1024,
      height: 768,
      parent: mainWindow,
      modal: true,
      show: false,
      autoHideMenuBar: true,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        nodeIntegration: true,
        contextIsolation: true,
      },
    });

    frameExtractorWindow.loadURL(VIDEO_FRAME_EXTRACTOR_WEBPACK_ENTRY);

    frameExtractorWindow.once("ready-to-show", () => {
      frameExtractorWindow?.webContents.send("theme-update", currentTheme);
      frameExtractorWindow?.show();
      frameExtractorWindow?.webContents.send("video-metadata", metadata);
    });
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(() => {
  // Set app user model id for windows
  electronApp.setAppUserModelId("com.electron");
  // Default open or close DevTools by F12 in development
  // and ignore CommandOrControl + R in production.
  // see https://github.com/alex8088/electron-toolkit/tree/master/packages/utils
  app.on("browser-window-created", (_, window) => {
    optimizer.watchWindowShortcuts(window);
  });

  createMainWindow();
  if (mainWindow) {
    registerIPCHandlers(mainWindow);
  }

  app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    //   // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
      createMainWindow();
    }
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

function registerIPCHandlers(mainWindow: BrowserWindow): void {
  function buildMenu() {
    const template: Array<Electron.MenuItemConstructorOptions> = [
      {
        label: "&Arquivo",
        submenu: [
          {
            label: "&Novo projeto",
            click: () => mainWindow.webContents.send("request-new-project"),
          },
          {
            type: "separator",
          },
          {
            label: "Carregar projet&o",
            click: () => mainWindow.webContents.send("request-load-project"),
          },
          {
            label: "&Salvar projeto",
            enabled: isProjectOpen,
            click: () => mainWindow.webContents.send("request-save-project"),
          },
          {
            label: "Salv&ar projeto como...",
            enabled: isProjectOpen,
            click: () =>
              mainWindow.webContents.send("request-save-project-as"),
          },
          {
            type: "separator",
          },
          {
            label: "&Fechar projeto",
            enabled: isProjectOpen,
            click: () => mainWindow.webContents.send("request-close-project"),
          },
          {
            type: "separator",
          },
          {
            label: "Sair",
            click: () => app.quit(),
          },
        ],
      },
      {
        label: "&Editar",
        submenu: [
          {
            label: "Copiar",
            accelerator: "Ctrl+C",
            enabled: canCopy,
            click: () => mainWindow.webContents.send("copy-to-clipboard"),
          },
          {
            label: "Colar",
            accelerator: "Ctrl+V",
            enabled: canPaste,
            click: () => mainWindow.webContents.send("paste-from-clipboard"),
          },
        ],
      },
      {
        label: "&Ajuda",
        submenu: [
          {
            label: "Sobre",
            click: () =>
              mainWindow.webContents.send("request-show-about-dialog"),
          },
        ],
      },
    ];
    const menu = Menu.buildFromTemplate(template);
    Menu.setApplicationMenu(menu);
  }

  // IPC test
  ipcMain.on("ping", () => console.log("pong"));

  ipcMain.on("open-external-link", (_, url) => {
    shell.openExternal(url);
  });

  // Change Theme on all windows
  ipcMain.on("change-theme", (_, newTheme: string) => {
    currentTheme = newTheme;
    for (const win of BrowserWindow.getAllWindows()) {
      win.webContents.send("theme-update", currentTheme);
    }
  });

  // Load video into vtd
  ipcMain.on("load-video", async (event) => {
    try {
      const { filePaths } = await dialog.showOpenDialog({
        properties: ["openFile"],
        filters: [
          {
            name: "Arquivos de Video",
            extensions: ["mkv", "mpg", "mpeg", "avi", "mov", "mp4"],
          },
          { name: "Todos os Arquivos", extensions: ["*"] },
        ],
      });
      if (filePaths.length > 0) {
        const filePath = filePaths[0];
        if (!fs.existsSync(filePath)) {
          event.reply("load-video-response", {
            success: false,
            message: "Arquivo de vídeo não encontrado.",
          });
          return;
        }

        const videoMetadata = await getMetadata(filePath);
        event.reply("load-video-response", {
          success: true,
          message: `Vídeo ${videoMetadata.format} carregado com sucesso. Abrindo VFE...`,
        });
        createFrameExtractorWindow(videoMetadata as IVideoMetadata);
      }
    } catch (err: unknown) {
      event.reply("load-video-response", {
        success: false,
        message: "Erro ao carregar arquivo de vídeo.",
      });
    }
  });

  // Generate thumbnail sprite
  ipcMain.on("generate-thumbnail-sprite", async (event, metadata) => {
    try {
      const thumbSprite = await generateThumbnailSprite(metadata);
      event.reply("generate-thumbnail-sprite-response", {
        success: true,
        message: "Imagem das miniaturas gerada com sucesso.",
        data: thumbSprite,
      });
    } catch (err) {
      event.reply("generate-thumbnail-sprite-response", {
        success: false,
        message: `Erro ao processar video. ${err}`,
      });
    }
  });

  // Process video frame
  ipcMain.on("process-video-frame", async (event, filePath, timeInSeconds) => {
    try {
      const videoFrame = await processVideoFrame(filePath, timeInSeconds);
      event.reply("process-video-frame-response", {
        success: true,
        message: `Quadro em ${timeInSeconds} segundos extraído com sucesso.`,
        data: videoFrame,
      });
    } catch (err) {
      event.reply("process-video-frame-response", {
        success: false,
        message: "Erro ao processar frame.",
      });
    }
  });

  // Send frame to WorkArea
  ipcMain.on("send-frame-to-work-area", async (_, imageUrl) => {
    mainWindow.webContents.send("load-image-response", {
      success: true,
      data: imageUrl,
      message: "Quadro extraído do vídeo com sucesso.",
    });
  });

  // Load images into vtd
  ipcMain.on("load-image", async (event) => {
    const { filePaths } = await dialog.showOpenDialog({
      properties: ["openFile"],
      filters: [
        {
          name: "Arquivos de Imagem",
          extensions: ["jpg", "jpeg", "png", "svg", "bmp"],
        },
        { name: "Arquivos Bitmap", extensions: ["bmp"] },
        { name: "Arquivos JPG", extensions: ["jpg, jpeg"] },
        { name: "Arquivos PNG", extensions: ["png"] },
        { name: "Arquivos SVG", extensions: ["svg"] },
        { name: "Todos os Arquivos", extensions: ["*"] },
      ],
    });
    if (filePaths.length > 0) {
      const filePath = filePaths[0];
      const extension = filePath.split(".").pop()?.toLowerCase();
      fs.readFile(
        filePaths[0],
        (err: NodeJS.ErrnoException | null, data: Buffer) => {
          if (err) {
            event.reply("load-image-response", {
              success: false,
              message: "Falha ao carregar arquivo de imagem.",
            });
            return;
          }
          const base64 = Buffer.from(data).toString("base64");
          let mimeType = "";
          switch (extension) {
            case "svg":
              mimeType = "image/svg+xml";
              break;
            case "jpg":
            case "jpeg":
              mimeType = "image/jpeg";
              break;
          }
          event.reply("load-image-response", {
            success: true,
            message: `Imagem ${extension?.toUpperCase()} importada.`,
            data: `data:${mimeType};base64,${base64}`,
          });
        },
      );
    }
  });

  // Export Canvas as an image
  ipcMain.on(
    "export-canvas",
    async (
      event,
      { format, dataString }: { format: string; dataString: string },
    ) => {
      const { filePath } = await dialog.showSaveDialog({
        title: "Exportar Canvas",
        defaultPath: "canvas",
        filters: [
          {
            name: "Arquivos de Imagem",
            extensions: format === "jpeg" ? ["jpeg", "jpg"] : [format],
          },
        ],
      });
      if (filePath) {
        const base64Data = dataString.replace(/^data:image\/\w+;base64,/, "");
        const buffer = Buffer.from(base64Data, "base64");

        fs.writeFile(filePath, buffer, (err) => {
          if (err) {
            event.reply("export-canvas-response", {
              success: false,
              message: `Falha ao salvar arquivo em: ${filePath}`,
            });
            return;
          }
          event.reply("export-canvas-response", {
            success: true,
            message: `Canvas exportado com sucesso em: ${filePath}`,
          });
        });
      }
    },
  );

  // Save already existing project
  ipcMain.on(
    "request-save-project",
    async (event, projectData: Partial<IProjectData>) => {
      const projectDataString = JSON.stringify(projectData);
      fs.writeFile(currentFilePath, projectDataString, (err) => {
        if (err) {
          event.reply("save-project-response", {
            success: false,
            message: `Falha ao salvar projeto em: ${currentFilePath}`,
          });
          return;
        }
        event.reply("save-project-response", {
          success: true,
          message: `Projeto salvo em: ${currentFilePath}`,
        });
      });
    },
  );

  // Save project with a different name
  ipcMain.on(
    "request-save-project-as",
    async (event, projectData: Partial<IProjectData>) => {
      const { filePath } = await dialog.showSaveDialog(mainWindow, {
        title: "Salvar Projeto Como...",
        defaultPath: `${projectData.title}.json`,
        filters: [{ name: "Arquivos JSON", extensions: ["json"] }],
      });

      if (filePath) {
        currentFilePath = filePath;
        const fileName = currentFilePath
          .split(/[\\|/]/)
          .pop()
          ?.replace(/\.json/, "");
        const now = new Date().toISOString();
        const projectDataString = JSON.stringify({
          ...projectData,
          createDate: now,
          modifyDate: now,
          title: fileName,
        });
        fs.writeFile(currentFilePath, projectDataString, (err) => {
          if (err) {
            event.reply("save-project-response", {
              success: false,
              message: `Falha ao salvar projeto em: ${currentFilePath}`,
            });
            return;
          }
          event.reply("save-project-response", {
            success: true,
            message: `Projeto salvo em: ${currentFilePath}`,
          });
          fs.readFile(currentFilePath, "utf-8", (err, data: string) => {
            if (err) {
              event.reply("load-project-response", {
                success: false,
                message: `Falha ao carregar projeto: ${fileName}`,
              });
              return;
            }
            const projectData: IProjectData = JSON.parse(data);
            currentProjectTitle = projectData.title;
            if (mainWindow) {
              mainWindow?.setTitle(
                `Video Thumbnail Designer - ${currentProjectTitle}`,
              );
            }
            event.reply("load-project-response", {
              success: true,
              message: "Projeto carregado com sucesso.",
              data: projectData,
            });
          });
        });
      } else {
        event.reply("save-project-response", {
          success: false,
          message: "Salvamento de projeto cancelado.",
        });
      }
    },
  );

  // Load Project from file
  ipcMain.on("request-load-project", async (event) => {
    const { filePaths } = await dialog.showOpenDialog(mainWindow, {
      title: "Carregar Projeto",
      properties: ["openFile"],
      filters: [{ name: "Arquivos JSON", extensions: ["json"] }],
    });
    if (filePaths.length > 0) {
      currentFilePath = filePaths[0];
      const fileName = currentFilePath
        .split(/[\\|/]/)
        .pop()
        ?.replace(/\.json/, "");
      fs.readFile(currentFilePath, "utf-8", (err, data: string) => {
        if (err) {
          event.reply("load-project-response", {
            success: false,
            message: `Falha ao carregar projeto: ${fileName}`,
          });
          return;
        }
        const projectData: IProjectData = JSON.parse(data);
        currentProjectTitle = projectData.title || fileName || "Sem título";
        if (mainWindow) {
          mainWindow?.setTitle(
            `Video Thumbnail Designer - ${currentProjectTitle}`,
          );
        }
        event.reply("load-project-response", {
          success: true,
          message: "Projeto carregado com sucesso.",
          data: projectData,
        });
      });
    } else {
      event.reply("load-project-response", {
        success: false,
        message: "Nenhum projeto selecionado.",
      });
    }
  });

  ipcMain.on("set-window-title", (_, title) => {
    if (mainWindow) {
      if (title) {
        isProjectOpen = true;
        mainWindow.setTitle(`Video Thumbnail Designer - ${title}`);
      } else {
        isProjectOpen = false;
        mainWindow.setTitle(`Video Thumbnail Designer`);
      }
      buildMenu();
    }
  });

  ipcMain.on("selection-changed", (_, hasSelection) => {
    canCopy = hasSelection;
    buildMenu();
  });

  ipcMain.on("clipboard-changed", (_, hasContent) => {
    canPaste = hasContent;
    buildMenu();
  });
  buildMenu();
}
