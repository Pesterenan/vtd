import type { FfprobeData } from "fluent-ffmpeg";
import ffmpeg, { ffprobe } from "fluent-ffmpeg";
import { electronApp, optimizer } from "@electron-toolkit/utils";
import { app, BrowserWindow, dialog, ipcMain } from "electron";
import type { IVideoMetadata } from "src/types";
import fs from "fs";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const VIDEO_FRAME_EXTRACTOR_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

let mainWindow: BrowserWindow | null = null;
let frameExtractorWindow: BrowserWindow | null = null;

const createMainWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    autoHideMenuBar: true,
    height: 670,
    show: false,
    width: 900,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: true,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  mainWindow.on("ready-to-show", () => {
    mainWindow?.show();
  });

  // Open the DevTools.
  if (process.env.NODE_ENV === "development") {
    mainWindow.webContents.openDevTools();
  }

  mainWindow.on("closed", () => {
    mainWindow = null;
  });
};

const createFrameExtractorWindow = (metadata: IVideoMetadata): void => {
  if (mainWindow) {
    frameExtractorWindow = new BrowserWindow({
      width: 1024,
      height: 768,
      parent: mainWindow,
      modal: true,
      show: false,
      autoHideMenuBar: true,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        nodeIntegration: true,
        contextIsolation: true,
      },
    });

    frameExtractorWindow.loadURL(VIDEO_FRAME_EXTRACTOR_WEBPACK_ENTRY);

    frameExtractorWindow.once("ready-to-show", () => {
      frameExtractorWindow?.show();
      frameExtractorWindow?.webContents.send("video-metadata", metadata);
    });
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(() => {
  // Set app user model id for windows
  electronApp.setAppUserModelId("com.electron");

  // Default open or close DevTools by F12 in development
  // and ignore CommandOrControl + R in production.
  // see https://github.com/alex8088/electron-toolkit/tree/master/packages/utils
  app.on("browser-window-created", (_, window) => {
    optimizer.watchWindowShortcuts(window);
  });

  createMainWindow();

  app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    //   // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
      createMainWindow();
    }
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// IPC test
ipcMain.on("ping", () => console.log("pong"));

// Load video into vtd
ipcMain.on("load-video", async (event) => {
  const { filePaths } = await dialog.showOpenDialog({
    properties: ["openFile"],
    filters: [
      {
        name: "Arquivos de Video",
        extensions: ["mkv", "mpg", "mpeg", "avi", "mov", "mp4"],
      },
      { name: "Todos os Arquivos", extensions: ["*"] },
    ],
  });
  if (filePaths.length > 0) {
    const filePath = filePaths[0];
    if (!fs.existsSync(filePath)) {
      throw new Error("Arquivo não encontrado");
    }

    const videoMetadata = await new Promise((resolve, reject) => {
      ffprobe(filePath, (err: Error, metadata: FfprobeData) => {
        if (err) {
          reject(err);
        }
        const duration = metadata.format.duration;
        const width = metadata.streams[0].width;
        const height = metadata.streams[0].height;
        const frameRate = metadata.streams[0].r_frame_rate;
        const totalFrames = Math.floor(
          Number(duration) * Number(frameRate?.split("/")[0]),
        );
        console.log(`Duração: ${duration} segundos`);
        console.log(`Resolução: ${width}x${height}`);
        console.log(`Taxa de quadros: ${frameRate}`);
        console.log(`Quadros totais: ${totalFrames}`);
        if (duration && width && height && frameRate && totalFrames) {
          const parsedMetadata: IVideoMetadata = {
            filePath,
            duration,
            width,
            height,
            frameRate,
            totalFrames,
          };
          resolve(parsedMetadata);
        }
      });
    });
    if (videoMetadata instanceof Error) {
      event.reply("load-video-response", {
        success: false,
        message: "Couldn't parse video metadata.",
      });
      return;
    }
    event.reply("load-video-response", {
      success: true,
      message: "Video metadata parsed, opening VFE...",
    });
    createFrameExtractorWindow(videoMetadata as IVideoMetadata);
  }
});

// Process video frame
ipcMain.on("process-video-frame", async (event, filePath, timeInSeconds) => {
  console.log("Starting video frame process", filePath, timeInSeconds);

  const chunks: Uint8Array[] = [];
  const videoFrame = await new Promise((resolve, reject) => {
    ffmpeg(filePath)
      .seekInput(timeInSeconds) // Pula para o tempo especificado
      .frames(1) // Captura 1 frame
      .outputOptions("-f", "rawvideo") // Define o formato como rawvideo para obter os dados brutos dos pixels
      .outputOptions("-pix_fmt", "rgba") // Especifica o formato de pixel como RGBA (4 bytes por pixel)
      .outputOptions("-vcodec", "rawvideo") // Usa rawvideo como codec
      .pipe() // Pipe dos dados para o Node.js
      .on("data", (chunk: Uint8Array) => {
        chunks.push(chunk);
      })
      .on("end", () => {
        console.log("Frame processed");
        const totalSize = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
        const combined = new Uint8Array(totalSize);
        let offset = 0;
        for (const chunk of chunks) {
          combined.set(chunk, offset);
          offset += chunk.length;
        }
        resolve(combined); // Retorna os dados brutos do frame como Uint8Array
      })
      .on("error", (err: Error) => {
        event.reply("process-video-frame-response", {
          success: false,
          message: "Error processing frame.",
        });
        reject(err);
      });
  });

  event.reply("process-video-frame-response", {
    success: true,
    message: "Video frame processed.",
    data: videoFrame,
  });
});

// Send frame to WorkArea
ipcMain.on("send-frame-to-work-area", async (_, imageUrl) => {
  mainWindow?.webContents.send("load-image-response", {
    success: true,
    data: imageUrl,
    message: "Sending frame to work area",
  });
});

// Load images into vtd
ipcMain.on("load-image", async (event) => {
  const { filePaths } = await dialog.showOpenDialog({
    properties: ["openFile"],
    filters: [
      {
        name: "Arquivos de Imagem",
        extensions: ["jpg", "jpeg", "png", "svg", "bmp"],
      },
      { name: "Arquivos Bitmap", extensions: ["bmp"] },
      { name: "Arquivos JPG", extensions: ["jpg, jpeg"] },
      { name: "Arquivos PNG", extensions: ["png"] },
      { name: "Arquivos SVG", extensions: ["svg"] },
      { name: "Todos os Arquivos", extensions: ["*"] },
    ],
  });
  if (filePaths.length > 0) {
    const filePath = filePaths[0];
    const extension = filePath.split(".").pop()?.toLowerCase();
    fs.readFile(filePaths[0], (err: NodeJS.ErrnoException | null, data: Buffer) => {
      if (err) {
        console.log(err);
        event.reply("load-image-response", {
          success: false,
          message: "Failed to load file.",
        });
        return;
      }
      const base64 = Buffer.from(data).toString("base64");
      if (extension === "svg") {
        const base64Data = `data:image/svg+xml;base64,${base64}`;
        event.reply("load-image-response", {
          success: true,
          message: `Loading ${extension} image...`,
          data: base64Data,
        });
      } else {
        const mimeType = `image/${extension === "jpg" ? "jpeg" : extension}`;
        const base64Data = `data:${mimeType};base64,${base64}`;
        event.reply("load-image-response", {
          success: true,
          message: `Loading ${extension} image...`,
          data: base64Data,
        });
      }
    });
  }
});

// Export Canvas as a PNG
ipcMain.on(
  "export-canvas",
  async (event, { dataString }: { dataString: string }) => {
    const { filePath } = await dialog.showSaveDialog({
      title: "Exportar Canvas",
      defaultPath: "canvas.png",
      filters: [{ name: "PNG Files", extensions: ["png"] }],
    });
    if (filePath) {
      const base64Data = dataString.replace(/^data:image\/\w+;base64,/, "");
      const buffer = Buffer.from(base64Data, "base64");

      fs.writeFile(filePath, buffer, (err) => {
        if (err) {
          event.reply("export-canvas-response", {
            success: false,
            message: "Failed to save file.",
          });
          return;
        }
        event.reply("export-canvas-response", {
          success: true,
          message: "File saved successfully.",
        });
      });
    }
  },
);

// Save Project onto file
ipcMain.on(
  "save-project",
  async (event, { dataString }: { dataString: string }) => {
    const { filePath } = await dialog.showSaveDialog({
      title: "Salvar Projeto",
      defaultPath: "projeto.json",
      filters: [{ name: "JSON Files", extensions: ["json"] }],
    });
    if (filePath) {
      fs.writeFile(filePath, dataString, (err) => {
        if (err) {
          event.reply("save-project-response", {
            success: false,
            message: "Failed to save file.",
          });
          return;
        }
        event.reply("save-project-response", {
          success: true,
          message: "File saved successfully.",
        });
      });
    }
  },
);

// Load Project from file
ipcMain.on("load-project", async (event) => {
  const { filePaths } = await dialog.showOpenDialog({
    properties: ["openFile"],
    filters: [{ name: "JSON Files", extensions: ["json"] }],
  });
  if (filePaths.length > 0) {
    fs.readFile(filePaths[0], "utf-8", (err, data: string) => {
      if (err) {
        event.reply("load-project-response", {
          success: false,
          message: "Failed to load file.",
        });
        return;
      }
      event.reply("load-project-response", {
        success: true,
        message: "File loaded successfully.",
        data,
      });
    });
  } else {
    event.reply("load-project-response", {
      success: false,
      message: "No file selected.",
    });
  }
});
