import type { FfprobeData } from "fluent-ffmpeg";
import ffmpeg, { ffprobe } from "fluent-ffmpeg";
import { electronApp, optimizer } from "@electron-toolkit/utils";
import { app, BrowserWindow, dialog, ipcMain } from "electron";
import type { IVideoMetadata } from "src/types";
import fs from "fs";
import { PassThrough } from "stream";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const VIDEO_FRAME_EXTRACTOR_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

let mainWindow: BrowserWindow | null = null;
let frameExtractorWindow: BrowserWindow | null = null;

const createMainWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    autoHideMenuBar: true,
    height: 670,
    show: false,
    width: 900,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: true,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  mainWindow.on("ready-to-show", () => {
    mainWindow?.show();
  });

  // Open the DevTools.
  if (process.env.NODE_ENV === "development") {
    mainWindow.webContents.openDevTools();
  }

  mainWindow.on("closed", () => {
    mainWindow = null;
  });
};

const createFrameExtractorWindow = (metadata: IVideoMetadata): void => {
  if (mainWindow) {
    frameExtractorWindow = new BrowserWindow({
      width: 1024,
      height: 768,
      parent: mainWindow,
      modal: true,
      show: false,
      autoHideMenuBar: true,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        nodeIntegration: true,
        contextIsolation: true,
      },
    });

    frameExtractorWindow.loadURL(VIDEO_FRAME_EXTRACTOR_WEBPACK_ENTRY);

    frameExtractorWindow.once("ready-to-show", () => {
      frameExtractorWindow?.show();
      frameExtractorWindow?.webContents.send("video-metadata", metadata);
    });
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(() => {
  // Set app user model id for windows
  electronApp.setAppUserModelId("com.electron");

  // Default open or close DevTools by F12 in development
  // and ignore CommandOrControl + R in production.
  // see https://github.com/alex8088/electron-toolkit/tree/master/packages/utils
  app.on("browser-window-created", (_, window) => {
    optimizer.watchWindowShortcuts(window);
  });

  createMainWindow();

  app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    //   // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
      createMainWindow();
    }
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// IPC test
ipcMain.on("ping", () => console.log("pong"));

// Load video into vtd
ipcMain.on("load-video", async (event) => {
  const { filePaths } = await dialog.showOpenDialog({
    properties: ["openFile"],
    filters: [
      {
        name: "Arquivos de Video",
        extensions: ["mkv", "mpg", "mpeg", "avi", "mov", "mp4"],
      },
      { name: "Todos os Arquivos", extensions: ["*"] },
    ],
  });
  if (filePaths.length > 0) {
    const filePath = filePaths[0];
    if (!fs.existsSync(filePath)) {
      throw new Error("Arquivo não encontrado");
    }

    const videoMetadata = await new Promise((resolve, reject) => {
      console.log("iniciando análise de video:", filePath);
      ffprobe(filePath, (err: Error, metadata: FfprobeData) => {
        if (err) {
          console.error("Erro no ffprobe:", err);
          return reject(err);
        }
        try {
          const duration = metadata.format.duration;
          const width = metadata.streams[0].width;
          const height = metadata.streams[0].height;
          const frameRate = metadata.streams[0].r_frame_rate;
          const totalFrames = Math.floor(
            Number(duration) * Number(frameRate?.split("/")[0]),
          );
          console.log(`Duração: ${duration} segundos`);
          console.log(`Resolução: ${width}x${height}`);
          console.log(`Taxa de quadros: ${frameRate}`);
          console.log(`Quadros totais: ${totalFrames}`);
          if (duration && width && height && frameRate && totalFrames) {
            const parsedMetadata: IVideoMetadata = {
              filePath,
              duration,
              width,
              height,
              frameRate,
              totalFrames,
            };
            console.log("Metadados obtidos:", parsedMetadata);
            resolve(parsedMetadata);
          } else {
            reject(new Error("Couldn't parse video metadata."));
          }
        } catch (parseError) {
          reject(parseError);
        }
      });
    });
    if (videoMetadata instanceof Error) {
      event.reply("load-video-response", {
        success: false,
        message: "Couldn't parse video metadata.",
      });
      return;
    }
    event.reply("load-video-response", {
      success: true,
      message: "Video metadata parsed, opening VFE...",
    });
    createFrameExtractorWindow(videoMetadata as IVideoMetadata);
  }
});

async function processVideoFrame(
  filePath: string,
  timeInSeconds: number,
): Promise<Uint8Array> {
  return new Promise((resolve, reject) => {
    const stream = new PassThrough();

    ffmpeg(filePath)
      .seekInput(timeInSeconds)
      .frames(1)
      .outputOptions([
        "-f",
        "image2pipe",
        "-pix_fmt",
        "rgba",
        "-vcodec",
        "rawvideo",
      ])
      .on("error", (err) => {
        reject(`Erro ao processar o vídeo: ${err}`);
        stream.end();
      })
      .on("end", () => {
        console.log("Frame extraído com sucesso!");
      })
      .pipe(stream, { end: true });

    const buffer = streamToBuffer(stream);
    resolve(buffer);
  });
}

function streamToBuffer(stream: PassThrough): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Uint8Array[] = [];
    stream.on("data", (chunk) => chunks.push(chunk));
    stream.on("end", () => resolve(Buffer.concat(chunks)));
    stream.on("error", reject);
  });
}

// Process video frame
ipcMain.on("process-video-frame", async (event, filePath, timeInSeconds) => {
  console.log("Starting video frame process", filePath, timeInSeconds);
  try {
    const videoFrame = await processVideoFrame(filePath, timeInSeconds);
    event.reply("process-video-frame-response", {
      success: true,
      message: "Video frame processed.",
      data: videoFrame,
    });
  } catch (err) {
    console.error(err, "erro ao preocessar frame");
    event.reply("process-video-frame-response", {
      success: false,
      message: "Error processing frame.",
    });
  }
});

// Send frame to WorkArea
ipcMain.on("send-frame-to-work-area", async (_, imageUrl) => {
  mainWindow?.webContents.send("load-image-response", {
    success: true,
    data: imageUrl,
    message: "Sending frame to work area",
  });
});

// Load images into vtd
ipcMain.on("load-image", async (event) => {
  const { filePaths } = await dialog.showOpenDialog({
    properties: ["openFile"],
    filters: [
      {
        name: "Arquivos de Imagem",
        extensions: ["jpg", "jpeg", "png", "svg", "bmp"],
      },
      { name: "Arquivos Bitmap", extensions: ["bmp"] },
      { name: "Arquivos JPG", extensions: ["jpg, jpeg"] },
      { name: "Arquivos PNG", extensions: ["png"] },
      { name: "Arquivos SVG", extensions: ["svg"] },
      { name: "Todos os Arquivos", extensions: ["*"] },
    ],
  });
  if (filePaths.length > 0) {
    const filePath = filePaths[0];
    const extension = filePath.split(".").pop()?.toLowerCase();
    fs.readFile(
      filePaths[0],
      (err: NodeJS.ErrnoException | null, data: Buffer) => {
        if (err) {
          console.log(err);
          event.reply("load-image-response", {
            success: false,
            message: "Failed to load file.",
          });
          return;
        }
        const base64 = Buffer.from(data).toString("base64");
        if (extension === "svg") {
          const base64Data = `data:image/svg+xml;base64,${base64}`;
          event.reply("load-image-response", {
            success: true,
            message: `Loading ${extension} image...`,
            data: base64Data,
          });
        } else {
          const mimeType = `image/${extension === "jpg" ? "jpeg" : extension}`;
          const base64Data = `data:${mimeType};base64,${base64}`;
          event.reply("load-image-response", {
            success: true,
            message: `Loading ${extension} image...`,
            data: base64Data,
          });
        }
      },
    );
  }
});

// Export Canvas as a PNG
ipcMain.on(
  "export-canvas",
  async (event, { dataString }: { dataString: string }) => {
    const { filePath } = await dialog.showSaveDialog({
      title: "Exportar Canvas",
      defaultPath: "canvas.png",
      filters: [{ name: "PNG Files", extensions: ["png"] }],
    });
    if (filePath) {
      const base64Data = dataString.replace(/^data:image\/\w+;base64,/, "");
      const buffer = Buffer.from(base64Data, "base64");

      fs.writeFile(filePath, buffer, (err) => {
        if (err) {
          event.reply("export-canvas-response", {
            success: false,
            message: "Failed to save file.",
          });
          return;
        }
        event.reply("export-canvas-response", {
          success: true,
          message: "File saved successfully.",
        });
      });
    }
  },
);

// Save Project onto file
ipcMain.on(
  "save-project",
  async (event, { dataString }: { dataString: string }) => {
    const { filePath } = await dialog.showSaveDialog({
      title: "Salvar Projeto",
      defaultPath: "projeto.json",
      filters: [{ name: "JSON Files", extensions: ["json"] }],
    });
    if (filePath) {
      fs.writeFile(filePath, dataString, (err) => {
        if (err) {
          event.reply("save-project-response", {
            success: false,
            message: "Failed to save file.",
          });
          return;
        }
        event.reply("save-project-response", {
          success: true,
          message: "File saved successfully.",
        });
      });
    }
  },
);

// Load Project from file
ipcMain.on("load-project", async (event) => {
  const { filePaths } = await dialog.showOpenDialog({
    properties: ["openFile"],
    filters: [{ name: "JSON Files", extensions: ["json"] }],
  });
  if (filePaths.length > 0) {
    fs.readFile(filePaths[0], "utf-8", (err, data: string) => {
      if (err) {
        event.reply("load-project-response", {
          success: false,
          message: "Failed to load file.",
        });
        return;
      }
      event.reply("load-project-response", {
        success: true,
        message: "File loaded successfully.",
        data,
      });
    });
  } else {
    event.reply("load-project-response", {
      success: false,
      message: "No file selected.",
    });
  }
});
